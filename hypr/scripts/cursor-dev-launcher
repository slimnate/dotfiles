#!/bin/bash
# Save as: ~/.local/share/omarchy/bin/omarchy-launch-cursor-project
# Make executable: chmod +x ~/.local/share/omarchy/bin/omarchy-launch-cursor-project
# considering switching to rofi instead of walker: https://github.com/davatorium/rofi/blob/next/doc/rofi-script.5.markdown
# also considering making this editor agnostic, so that it can be used with other code editors like vscode, sublime text, etc.

set -euo pipefail

# Configure where to look for projects
# - BASE_DIRS: directories whose immediate subfolders are considered projects
# - PROJECTS: individual project directories to include explicitly
#   To override a project's display name, use the format:
#   "My Label|/absolute/path/to/project". Without a label, the basename is used.
BASE_DIRS=(
  "$HOME/Documents/dev"
)
PROJECTS=(
  "Custom Dotfiles|$HOME/.dotfiles"
  "Omarchy local config|$HOME/.local/share/omarchy"
)

# Debug logging (export CURSOR_DEV_DEBUG=1 to enable)
DEBUG="${CURSOR_DEV_DEBUG:-0}"
LOG_FILE="${CURSOR_DEV_LOG:-/tmp/cursor-dev-launcher.log}"
# Menu width for dmenu mode (walker 2.x ignores -w; use wrapper width)
CURSOR_MENU_WIDTH="${CURSOR_MENU_WIDTH:-1100}"
# Fixed menu height (set both min/max to this value)
CURSOR_MENU_HEIGHT="${CURSOR_MENU_HEIGHT:-600}"
# Menu formatting and info toggles
MENU_COLS="${CURSOR_MENU_COLS:-96}"
# Max visible branch name length (characters); longer branches are truncated with …
BRANCH_MAX="${CURSOR_BRANCH_MAX:-24}"
# Toggle which info segments to show (0/1)
SHOW_STATUS="${CURSOR_SHOW_STATUS:-1}"
SHOW_ACTIVITY="${CURSOR_SHOW_ACTIVITY:-1}"
SHOW_TAGS="${CURSOR_SHOW_TAGS:-0}"

log() {
  if [[ "$DEBUG" == 1 ]]; then
    printf '%s %s\n' "$(date '+%F %T')" "$*" >> "$LOG_FILE"
  fi
}

# Ensure at least one source exists; continue even if some are missing
has_source=false
for d in "${BASE_DIRS[@]}"; do
  if [[ -d "$d" ]]; then has_source=true; break; fi
done
if [[ ${#PROJECTS[@]} -gt 0 ]]; then has_source=true; fi
if [[ "$has_source" == false ]]; then
  notify-send "Projects" "No sources found. Check BASE_DIRS/PROJECTS in the launcher script."
  exit 1
fi

# Parse PROJECTS into absolute paths and a label map for custom display names
declare -A PROJECT_LABEL_FOR_PATH
INDIVIDUAL_PROJECT_PATHS=()
parse_projects() {
  PROJECT_LABEL_FOR_PATH=()
  INDIVIDUAL_PROJECT_PATHS=()
  local entry label path
  for entry in "${PROJECTS[@]}"; do
    [[ -n "${entry:-}" ]] || continue
    if [[ "$entry" == *"|"* ]]; then
      label="${entry%%|*}"
      path="${entry#*|}"
    else
      label=""
      path="$entry"
    fi
    [[ -d "$path" ]] || continue
    INDIVIDUAL_PROJECT_PATHS+=("$path")
    if [[ -n "$label" ]]; then
      PROJECT_LABEL_FOR_PATH["$path"]="$label"
    fi
  done
}

# Resolve a display name for a project path; fallback to provided default
get_display_name() {
  local path="$1"; local fallback="$2"
  if [[ -n "${PROJECT_LABEL_FOR_PATH[$path]+x}" ]]; then
    printf "%s\n" "${PROJECT_LABEL_FOR_PATH[$path]}"
  else
    printf "%s\n" "$fallback"
  fi
}

# List absolute project directories from BASE_DIRS (immediate children) and PROJECTS
list_projects() {
  {
    for d in "${BASE_DIRS[@]}"; do
      [[ -d "$d" ]] || continue
      find -L "$d" -mindepth 1 -maxdepth 1 -type d -print
    done
    for p in "${INDIVIDUAL_PROJECT_PATHS[@]}"; do
      printf '%s\n' "$p"
    done
  } | sort -u
}

# Find the most recent modification time (epoch) within a project directory
latest_mtime() {
  local path="$1"
  # Ignore heavy/vendor dirs for speed
  local ts
  ts="$(find -L "$path" \
      -path "$path/.git" -prune -o \
      -path "$path/node_modules" -prune -o \
      -type f -printf '%T@\n' 2>/dev/null | sort -nr | head -1)"
  if [[ -z "${ts:-}" ]]; then
    stat -c %Y "$path" 2>/dev/null || echo 0
  else
    printf '%.0f\n' "$ts"
  fi
}

# Convert epoch seconds to a compact relative string (e.g. 3h ago)
humanize_epoch() {
  local t="$1"
  local now diff
  now="$(date +%s)"
  diff=$(( now - t ))
  if (( diff < 60 )); then
    echo "${diff}s ago"
  elif (( diff < 3600 )); then
    echo "$(( diff / 60 ))m ago"
  elif (( diff < 86400 )); then
    echo "$(( diff / 3600 ))h ago"
  else
    echo "$(( diff / 86400 ))d ago"
  fi
}

# Ensure a value is a single line without tabs/newlines
one_line() {
  printf '%s' "$1" | tr '\r\n\t' '   '
}

# Emit a single tab-separated row for a project with a numeric timestamp for sorting
project_row() {
  local path="$1"
  local name
  name="$(basename -- "$path")"
  name="$(one_line "$name")"
  name="$(get_display_name "$path" "$name")"

  local ts human last_author branch dirty ahead behind tags
  tags=""

  # Tech stack tags
  [[ -f "$path/package.json" ]] && tags+="node "
  [[ -f "$path/pnpm-lock.yaml" ]] && tags+="pnpm "
  [[ -f "$path/yarn.lock" ]] && tags+="yarn "
  [[ -f "$path/bun.lockb" ]] && tags+="bun "
  [[ -f "$path/go.mod" ]] && tags+="go "
  [[ -f "$path/pyproject.toml" || -f "$path/requirements.txt" ]] && tags+="python "
  [[ -f "$path/Cargo.toml" ]] && tags+="rust "
  [[ -f "$path/composer.json" ]] && tags+="php "
  [[ -f "$path/.tool-versions" || -f "$path/.mise.toml" ]] && tags+="mise "
  [[ -d "$path/.devcontainer" ]] && tags+="devcontainer "
  [[ -f "$path/Dockerfile" || -f "$path/docker-compose.yml" ]] && tags+="docker "
  [[ -d "$path/tests" || -d "$path/test" ]] && tags+="tests "
  tags="${tags%% }"

  # Always sort by latest file modification time in the project
  ts="$(latest_mtime "$path")"
  human="$(humanize_epoch "$ts")"
  last_author="-"

  if git -C "$path" rev-parse --git-dir >/dev/null 2>&1; then
    # Branch (handle detached HEAD)
    branch="$(git -C "$path" rev-parse --abbrev-ref HEAD 2>/dev/null || echo '-')"
    branch="$(one_line "$branch")"
    # Truncate branch to BRANCH_MAX characters if needed
    if [[ -n "$branch" && "$branch" != "-" ]]; then
      if (( ${#branch} > BRANCH_MAX )); then
        branch="${branch:0:$((BRANCH_MAX-1))}…"
      fi
    fi

    # Dirty files count
    dirty="$(git -C "$path" status --porcelain 2>/dev/null | wc -l | awk '{print $1}')"

    # Ahead/behind relative to upstream if configured
    if git -C "$path" rev-parse --abbrev-ref --symbolic-full-name @{u} >/dev/null 2>&1; then
      read -r ahead behind < <(git -C "$path" rev-list --left-right --count HEAD...@{u} 2>/dev/null | awk '{print $1, $2}')
    else
      ahead="0"; behind="0"
    fi
  else
    # Non-git projects: placeholders
    branch="-"
    dirty="0"
    ahead="0"
    behind="0"
  fi

  # Compose a compact status field
  local status
  status="${branch} • ${dirty}Δ • ${ahead}↑ ${behind}↓"
  status="$(one_line "$status")"

  # Compose subtext for last activity (based on file mtime only)
  local activity
  activity="$human"
  activity="$(one_line "$activity")"

  # Output: ts (for sort) \t name \t status \t activity \t tags \t abs_path
  # Sanitize tags and path as one-line too
  tags="$(one_line "$tags")"
  path="$(one_line "$path")"
  printf "%s\t%s\t%s\t%s\t%s\t%s\n" "$ts" "$name" "$status" "$activity" "$tags" "$path"
}

# Build dmenu items: label (pretty) and value (absolute path), select by value
parse_projects
raw_rows_file="$(mktemp /tmp/cursor-dev-raw.XXXX.tsv)"
menu_feed_file="$(mktemp /tmp/cursor-dev-feed.XXXX.tsv)"
cleanup() { [[ "$DEBUG" == 1 ]] || rm -f "$raw_rows_file" "$menu_feed_file"; }
trap cleanup EXIT

log "Scanning sources: BASE_DIRS=(${BASE_DIRS[*]}) PROJECTS=(${PROJECTS[*]})"

selection="$(
  list_projects \
    | while read -r path; do project_row "$path"; done \
    | sort -rn -k1,1 | tee "$raw_rows_file" \
    | awk -F '\t' -v TOTAL_COLS="${MENU_COLS}" -v SHOW_STATUS="${SHOW_STATUS}" -v SHOW_ACTIVITY="${SHOW_ACTIVITY}" -v SHOW_TAGS="${SHOW_TAGS}" 'BEGIN{OFS="\t"} { \
        # Require both label source and value (abs path)
        if ($2 == "" || $6 == "") next; \
        name = $2; \
        info = ""; \
        if (SHOW_STATUS == 1) info = $3; \
        if (SHOW_ACTIVITY == 1 && $4 != "-") { if (info != "") info = info " — "; info = info $4; } \
        if (SHOW_TAGS == 1 && $5 != "") { if (info != "") info = info " — "; info = info $5; } \
        # Right-justify info to TOTAL_COLS by shrinking name and adding left padding before info
        allowed = TOTAL_COLS - length(info) - 1; \
        if (allowed < 2) { name = "…"; allowed = 1; } \
        else if (length(name) > allowed) name = substr(name, 1, allowed-1) "…"; \
        pad_len = TOTAL_COLS - length(info) - length(name); if (pad_len < 1) pad_len = 1; \
        pad = sprintf("%" pad_len "s", ""); \
        label = name pad info; \
        value = $6; \
        print label, value \
      }' | tee "$menu_feed_file" \
    | { \
        cmd="walker"; \
        if command -v omarchy-launch-walker >/dev/null 2>&1; then cmd="omarchy-launch-walker"; fi; \
        "$cmd" --dmenu --width "$CURSOR_MENU_WIDTH" --minheight "$CURSOR_MENU_HEIGHT" --maxheight "$CURSOR_MENU_HEIGHT" -p 'Open in Cursor…'; \
      } || true

)"

# Walker returns nothing on cancel; handle gracefully
if [[ -z "${selection:-}" || "$selection" == "CNCLD" ]]; then
  exit 0
fi

# In Walker 2.x dmenu, the full row is returned. Extract path from 2nd TSV field.
selection_path="$(printf "%s" "$selection" | awk -F '\t' '{print $2}')"
if [[ -z "${selection_path:-}" ]]; then
  # Fallback: if only one field came back, assume it is the path
  selection_path="$selection"
fi
log "Selected value: $selection_path"
if [[ "$DEBUG" == 1 ]]; then
  log "Raw rows saved: $raw_rows_file (lines=$(wc -l < "$raw_rows_file"))"
  log "Menu feed saved: $menu_feed_file (lines=$(wc -l < "$menu_feed_file"))"
  # Verify that the selected path exists in the menu feed's second column
  if ! awk -F '\t' -v sel="$selection" '$2==sel {found=1} END{exit found?0:1}' "$menu_feed_file"; then
    log "WARNING: Selected value not found in menu feed second column"
  fi
fi

# selection_path is the absolute path (value column)
exec uwsm app -- cursor "$selection_path"